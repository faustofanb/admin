# 后台管理系统消息模块集成指南 (JDK 25 / Spring Boot 3)

本文档旨在指导开发者如何利用 `shared-message` 模块实现业务解耦和分布式通信。本模块核心基于 **Virtual Threads** (虚拟线程) 和 **Spring Event** + **Pulsar** 构建。

## 1. 核心组件概览

请对照项目中的类文件理解以下概念：

| 类名/文件名 | 类型 | 说明 |
| :--- | :--- | :--- |
| **`MessageBus`** | 核心服务 | **(唯一入口)** 业务层通过此 Bean 发布消息，内部自动路由。 |
| **`SysMessage<T>`** | 领域模型 | **(消息信封)** 统一的消息包装 Record，包含 Header、Topic、Payload。 |
| **`MsgScope`** | 枚举 | 定义传播范围：`LOCAL` (进程内), `REMOTE` (跨进程), `GLOBAL` (混合)。 |
| **`MsgConstants`** | 常量类 | 存放系统级常量，推荐在此处或业务常量类中定义 Topic。 |
| **`RemoteMessageProvider`** | 接口 (SPI) | 底层发送接口，目前实现为 `PulsarMessageProvider`。 |

---

## 2. 快速集成步骤

### 第一步：定义领域事件 (Domain Event)

**规范：**
1.  使用 **Java Record** 定义，确保不可变性。
2.  必须实现 `Serializable`。
3.  纯 POJO，不包含业务逻辑。

```java
package com.sys.biz.order.event;

import java.io.Serializable;
import java.math.BigDecimal;

/**
 * 订单支付成功事件
 */
public record OrderPaidEvent(
    String orderId, 
    Long userId, 
    BigDecimal amount
) implements Serializable {}
```

### 第二步：定义 Topic 常量

**严禁使用魔法字符串**。建议在各业务模块定义常量类，或在 `MsgConstants` 统一管理。

```java
package com.sys.biz.order.constant;

public interface OrderTopics {
    // 命名规范：业务域.动作.对象
    String TOPIC_ORDER_PAID = "biz.order.paid";
}
```

### 第三步：发布消息 (Producer)

在 Service 中注入 `MessageBus`，构建 `SysMessage` 并发布。

```java
package com.sys.biz.order.service;

import com.sys.admin.shared.message.MessageBus; // 核心入口
import com.sys.admin.shared.message.SysMessage; // 消息信封
import com.sys.admin.shared.message.MsgScope;   // 作用域
import com.sys.biz.order.constant.OrderTopics;
import com.sys.biz.order.event.OrderPaidEvent;
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final MessageBus messageBus;

    public OrderService(MessageBus messageBus) {
        this.messageBus = messageBus;
    }

    public void payOrder(String orderId) {
        // ... 业务逻辑 ...

        // 1. 准备载荷
        var payload = new OrderPaidEvent(orderId, 1001L, new BigDecimal("99.00"));

        // 2. 构建消息信封 (使用 Builder)
        var message = SysMessage.<OrderPaidEvent>builder()
                .topic(OrderTopics.TOPIC_ORDER_PAID) // 使用常量
                .scope(MsgScope.GLOBAL)              // GLOBAL = 本地广播 + 发送MQ
                .payload(payload)
                .build();

        // 3. 发布 (虚拟线程异步执行，不会阻塞当前方法)
        messageBus.publish(message);
    }
}
```

---

## 3. 消费指南

### 场景 A：本地监听 (进程内解耦)

当 `MsgScope` 为 `LOCAL` 或 `GLOBAL` 时触发。

使用 Spring 标准的 `@EventListener`，**必须指定泛型 `SysMessage<T>`** 以实现精确匹配。

```java
@Component
public class OrderLogListener {

    @EventListener
    public void onOrderPaid(SysMessage<OrderPaidEvent> message) {
        // 双重校验 Topic (推荐)
        if (OrderTopics.TOPIC_ORDER_PAID.equals(message.topic())) {
            OrderPaidEvent event = message.payload();
            System.out.println("本地日志记录: " + event.orderId());
        }
    }
}
```

### 场景 B：远程监听 (Pulsar 跨服务)

当 `MsgScope` 为 `REMOTE` 或 `GLOBAL` 时触发。

其他微服务使用 Spring Pulsar 的 `@PulsarListener` 监听。注意：**消费者直接接收 Payload (领域事件)**，而不是 `SysMessage` 包装类（底层 `PulsarMessageProvider` 已自动拆包序列化）。

```java
@Component
public class UserPointsConsumer {

    @PulsarListener(
        topics = OrderTopics.TOPIC_ORDER_PAID, // 使用相同的常量
        subscriptionName = "sub-user-points"
    )
    public void onMessage(OrderPaidEvent event) {
        // 这里的 event 就是 OrderPaidEvent record
        System.out.println("给用户增加积分: " + event.userId());
    }
}
```

---

## 4. 高级特性与原理

### 4.1 虚拟线程 (Virtual Threads)
*   **特性**: `MessageBus.publish()` 方法内部会将任务提交给 `msgVirtualExecutor` (在 `MessageConfig` 中定义)。
*   **优势**: 即使底层 Pulsar 网络 I/O 发生阻塞，也不会消耗操作系统的平台线程。你可以在高并发接口中放心调用 `publish`。

### 4.2 重试机制
*   `RemoteMessageProvider` 内部集成了 `RetryUtils`。
*   如果发送 Pulsar 失败，系统会自动进行指数退避重试（默认 3 次），无需业务层手动编写重试循环。

### 4.3 链路追踪
*   `SysMessage` 支持 metadata (Map<String, String>)。
*   默认情况下，Tracing Filter 会将 TraceId 注入 metadata，随消息跨越进程，便于 SkyWalking / Zipkin 追踪。

---

## 5. 常见问题 (FAQ)

**Q1: 为什么消费者收到的对象属性是 null？**
*   检查 Domain Event (Record) 是否实现了 `Serializable`。
*   检查发送端和消费端的 Record 定义是否一致（包名可以不同，但字段名和类型必须一致，Jackson 序列化依赖）。

**Q2: 如何只发送到 MQ，不触发本地监听？**
*   构建消息时设置 `.scope(MsgScope.REMOTE)`。

**Q3: 为什么我看不到 `MessageTransport` 类？**
*   根据最新架构，该接口已重命名为 **`RemoteMessageProvider`**，其实现类为 `PulsarMessageProvider`。请面向接口编程。

**Q4: Topic 命名有什么强制要求吗？**
*   推荐格式：`业务域-事件类型` (kebab-case) 或 `业务域.事件类型` (dot-notation)。
*   必须在常量类中定义，**Code Review 发现魔法字符串将被打回**。