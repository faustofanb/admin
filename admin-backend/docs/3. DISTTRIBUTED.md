# 分布式治理模块使用指南

## 1. 模块简介

本模块基于 **Redisson** 和 **Java 25** 构建，旨在解决微服务/分布式环境下的**协同与管控**问题。

### 核心能力

* **分布式锁 (Locking)**: 解决跨节点的资源竞争问题，支持可重入、公平锁等多种策略。
* **接口幂等性 (Idempotency)**: 基于状态机 (`PENDING` -> `SUCCESS` / `FAIL`) 实现，防止重复提交并支持结果缓存。
* **基础设施操作 (Infrastructure Ops)**: 提供类型安全、无魔法值的 Redis 原子操作封装（如黑名单、全局配置）。

### 技术特性

* **JDK Version**: Java 25 (利用 `Record`, `Switch Expression`, `Virtual Thread` 优化)。
* **原则**: 严禁魔法字符串，高内聚，业务逻辑与 Redis 操作解耦。

---

## 2. 核心规范 (必读)

### Key 注册机制

本模块**禁止**在业务代码中直接拼接字符串作为 Redis Key。所有的 Key 必须在 `RedisKeyRegistry` 枚举中统一注册。

**步骤：**

1. 打开 `com.platform.distributed.constants.RedisKeyRegistry`。
2. 定义新的枚举项，指定 **前缀 (Prefix)**、**默认TTL** 和 **描述**。

```java
// 示例：在 RedisKeyRegistry.java 中新增
// 格式 -> 模块:功能:细节:
public enum RedisKeyRegistry implements KeyDefinition {
    // ... 原有定义
  
    /** 示例：用户每日签到标记，有效期1天 */
    USER_DAILY_SIGN("BIZ:USER:SIGN:", Duration.ofDays(1), "用户每日签到"),
}
```

---

## 3. 功能一：分布式锁

### 方式 A：注解驱动 (推荐)

适用于整个方法需要加锁的场景。

```java
@Service
public class OrderService {

    // key 支持 SpEL 表达式
    // leaseTime = -1 表示启用"看门狗"机制，自动续期，防止业务没执行完锁就过期
    @GlobalLock(key = "'pay_order:' + #orderId", waitTime = 3, leaseTime = -1)
    public void payOrder(String orderId, BigDecimal amount) {
        // 业务逻辑...
    }
}
```

### 方式 B：编程式调用 (灵活性高)

适用于只需要锁住方法内部某一段逻辑，或者需要更复杂的锁控制。

```java
@Service
public class InventoryService {
  
    @Autowired
    private DistributedLockTemplate lockTemplate;

    public void deductStock(String productId) {
        // 使用函数式编程，自动处理 try-lock-finally unlock
        lockTemplate.run(productId, () -> {
            // 核心扣减库存逻辑
            // 只有拿到锁才会执行到这里
        });
    }

    public boolean checkStock(String productId) {
        // 带返回值的写法
        return lockTemplate.execute(productId, LockStrategy.REENTRANT, 5, 10, () -> {
            return repo.getStock(productId) > 0;
        });
    }
}
```

---

## 4. 功能二：接口幂等性

基于**状态机**设计，不仅仅是防抖，还能缓存执行结果。

* **PENDING**: 请求正在处理中 -> 再次请求会抛出异常。
* **SUCCESS**: 请求已成功 -> 再次请求直接返回上次的 Result (不执行业务代码)。
* **FAIL**: 请求失败 -> 再次请求会重新执行业务逻辑 (允许重试)。

### 使用方式

```java
@RestController
@RequestMapping("/api/payments")
public class PaymentController {

    /**
     * key: 唯一标识业务的ID (如请求ID，或者订单号)
     * message: 触发并发冲突时的提示语
     */
    @GlobalIdempotent(key = "#request.requestId", message = "正在处理中，请勿重复点击")
    @PostMapping
    public PaymentResult createPayment(@RequestBody PaymentRequest request) {
        // 1. 如果是第一次请求：执行逻辑，保存结果到 Redis，返回结果。
        // 2. 如果是重复请求(且上次成功)：直接从 Redis 拉取 PaymentResult 返回。
        return paymentService.process(request);
    }
}
```

---

## 5. 功能三：Redis 基础运维操作

通过 `RedisUtil` 工具类进行操作，主要用于**黑名单管理**、**开关配置**、**状态标记**等非缓存类数据。

### 场景示例

#### 1. Token 黑名单 (Security)

```java
@Component
public class SecurityManager {

    @Autowired
    private RedisUtil redisOps;

    // 登出：拉黑 Token
    public void logout(String token) {
        // 使用 Set 结构存储
        redisOps.addToSet(RedisKeyRegistry.SEC_BLACKLIST, "TOKENS", token);
    }

    // 校验
    public boolean isBlacklisted(String token) {
        return redisOps.isMemberOfSet(RedisKeyRegistry.SEC_BLACKLIST, "TOKENS", token);
    }
}
```

#### 2. 系统全局配置 (Config)

```java
@Service
public class SystemConfigService {

    @Autowired
    private RedisUtil redisOps;

    public void setMaintenanceMode(boolean enable) {
        // 使用 Bucket 存储简单值
        redisOps.set(RedisKeyRegistry.SYS_CONFIG, "MAINTENANCE_MODE", enable);
    }
  
    public boolean isMaintenanceMode() {
        return redisOps.get(RedisKeyRegistry.SYS_CONFIG, "MAINTENANCE_MODE")
                       .map(val -> (Boolean) val)
                       .orElse(false);
    }
}
```

---

## 7. 开发注意事项

1. **关于缓存**: 本模块**不是**缓存模块。如果是为了减轻数据库压力查询数据，请使用 Spring Cache (`@Cacheable`) 或独立的缓存 Service，不要使用 `RedisUtil`。本模块关注的是**控制** (Control)。
2. **SpEL 表达式**: 注解中的 `key` 参数支持 Spring Expression Language。
   * `#paramName`: 获取方法参数。
   * `#student.id`: 获取对象属性。
3. **Key 的后缀**: `ops.set(Registry.KEY, "suffix", value)`。最终 Redis 中的 Key 为 `Registry前缀` + `suffix`。请确保 suffix 具有业务唯一性。
