# 后台管理系统缓存使用指南 (Cache Guide)

## 1. 架构概述

本项目采用生产级 **L1 + L2 多级缓存架构**，旨在结合本地内存的高性能与分布式缓存的数据共享能力。

*   **L1 (本地缓存)**: 基于 **Caffeine**。响应速度微秒级，用于承载高频热点读取。通过 Redis Pub/Sub 机制实现集群间缓存失效同步。
*   **L2 (分布式缓存)**: 基于 **Redisson (Redis)**。响应速度毫秒级，提供数据持久化和共享能力。
*   **技术栈**: JDK 25 (Virtual Threads, Records), Spring Cache, Redisson.

---

## 2. 快速开发流程

在业务中使用缓存，请遵循以下三个步骤：

### 步骤一：定义常量 (CacheKeys)
所有缓存名称（CacheName）和键前缀（KeyPrefix）必须在 `CacheKeys` 类中定义，禁止在代码中使用魔法字符串。

文件位置: `io.github.faustofan.admin.shared.constant.CacheKeys`

```java
public final class CacheKeys {
    // ...
    // 1. 定义缓存区名称 (用于 @CacheConfig)
    public static final String AUTH_USER_CACHE = "ADMIN:AUTH:USER";

    // 2. 定义键前缀 (用于 SpEL 拼接，必须包含单引号)
    public static final String AUTH_KEY_ID = "'ID:'";
    public static final String AUTH_KEY_NAME = "'NAME:'";
}
```

### 步骤二：配置策略 (CachePolicy)
在枚举中定义该缓存区的 **TTL (过期时间)** 和 **L1 容量限制**。

文件位置: `io.github.faustofan.admin.cache.config.CachePolicy`

```java
public enum CachePolicy {
    // 关联 CacheName，配置 L1=1分钟, L2=30分钟
    USER_AUTH(CacheKeys.AUTH_USER_CACHE, Duration.ofMinutes(1), Duration.ofMinutes(30), 2000),
    
    // ... 其他策略
}
```

### 步骤三：业务使用 (Service Layer)
优先使用 Spring Cache 注解，确保代码简洁且非侵入。

```java
@Service
@CacheConfig(cacheNames = CacheKeys.AUTH_USER_CACHE) // 1. 指定缓存区
public class UserDetailsServiceImpl {

    /**
     * 查询缓存
     * sync = true: 开启分布式锁/本地锁，防止缓存击穿 (必填)
     * key 拼接: 常量 + SpEL变量
     */
    @Cacheable(key = CacheKeys.AUTH_KEY_ID + " + #userId", sync = true)
    public LoginUser loadUserById(Long userId) {
        return userRepository.findById(userId).orElseThrow();
    }

    /**
     * 更新/清理缓存
     * 建议使用 @CacheEvict 删除而非 @CachePut 更新，以避免并发脏写
     */
    @CacheEvict(key = CacheKeys.AUTH_KEY_ID + " + #userId")
    public void changePassword(Long userId, String newPassword) {
        // 业务逻辑...
    }
}
```

---

## 3. 进阶用法：编程式缓存 (CacheUtils)

当注解无法满足需求（如：在循环中操作、异步刷新、复杂的条件判断）时，请使用 `CacheUtils` 工具类。

```java
@Autowired
private CacheUtils cacheUtils;

public void complexBusiness() {
    String cacheName = CacheKeys.SYS_CONFIG_CACHE;
    String key = "global_switch";

    // 1. 函数式查询 (Get or Compute)
    // 利用 JDK 25 Lambda，自动处理多级缓存回填
    Boolean isOpen = cacheUtils.get(cacheName, key, Boolean.class, () -> {
        return dbRepository.findSwitchStatus();
    });

    // 2. 异步后台刷新 (Async Refresh)
    // 利用 Virtual Threads，不阻塞主线程，适合报表/大屏数据预热
    cacheUtils.refreshAsync(cacheName, key, () -> {
        // 执行耗时计算...
        return calculateHeavyReport();
    });
    
    // 3. 手动清理
    cacheUtils.evict(cacheName, key);
}
```

---

## 4. 命名与 Key 规范

为了维护 Redis 的整洁性，所有 Key 必须遵循以下格式：

| 组成部分 | 说明 | 示例 |
| :--- | :--- | :--- |
| **APP_PREFIX** | 全局前缀，固定为 `ADMIN:` | `ADMIN:` |
| **MODULE** | 模块名，全大写 | `AUTH:` |
| **RESOURCE** | 资源名，全大写 | `USER` |
| **TYPE** | 维度/属性 (SpEL中定义) | `ID:`, `NAME:` |
| **VALUE** | 实际值 (运行时参数) | `1001` |

**最终 Redis Key 示例**:
*   Hash结构 (Redisson Map): `ADMIN:AUTH:USER`
*   HashKey: `ID:1001`
*   HashKey: `NAME:1001:admin`

---

## 5. 最佳实践 (Best Practices)

### ✅ DOs (推荐)
1.  **始终开启 `sync = true`**: 在 `@Cacheable` 中，除非是极低频访问，否则务必加上 `sync = true`。这利用了 Redisson 的锁机制，完美解决**缓存击穿**问题。
2.  **使用 `Record`**: 强烈建议缓存对象使用 JDK `record` 类型（如 `LoginUser`, `ProductDto`）。Caffeine 是引用存储，不可变对象能防止某个线程修改了缓存对象导致污染其他线程的数据。
3.  **实现 `Serializable`**: 所有进入 L2 (Redis) 的对象必须实现 `Serializable` 接口。
4.  **注解 Key 使用常量**: `key = CacheKeys.PREFIX + " + #arg"`。

### ❌ DON'Ts (禁止)
1.  **禁止缓存大集合**: 不要直接缓存 `List<User>`。只要列表里一个人变了，整个列表都要失效，命中率极低。**正确做法**: 缓存 `List<Long> ids`，然后循环通过 `loadUserById` (走缓存) 获取详情。
2.  **禁止内部调用**: `this.method()` 调用不会触发 AOP 缓存拦截。如需同类调用，请注入 `ApplicationContext` 获取代理对象。
3.  **避免过长的 Key**: Key 过长会占用 Redis 内存且影响网络传输，保持语义清晰即可。

---

## 6. 常见问题排查

**Q1: 修改了数据库，缓存没变？**
*   检查是否调用了更新方法？
*   更新方法上是否加了 `@CacheEvict`？
*   Key 的拼接逻辑是否与 `@Cacheable` 完全一致？（例如：`ID:` vs `Id:`）

**Q2: 报错 `NotSerializableException`**
*   检查缓存对象及其内部嵌套的对象是否都实现了 `Serializable`。

**Q3: 多个节点缓存不一致**
*   这是 L1 缓存同步延迟导致的（通常 < 10ms）。
*   检查 Redis Pub/Sub 是否正常工作。
*   检查 `CacheKeys.TOPIC_L1_SYNC` 常量是否在所有节点一致。
*   对于强一致性要求的业务（如余额扣减），**不要读缓存**，请直接读主库或使用 Redis 原子操作。

---

## 7. 示例代码模板

### Service 层模板
```java
@Service
@CacheConfig(cacheNames = CacheKeys.PROD_INFO_CACHE)
public class ProductService {

    // 读
    @Cacheable(key = CacheKeys.PROD_KEY_ID + " + #id", sync = true)
    public ProductDto getById(Long id) {
        return repo.findById(id).map(ProductMapper::toDto).orElse(null);
    }

    // 写 (删缓存)
    @Transactional
    @CacheEvict(key = CacheKeys.PROD_KEY_ID + " + #dto.id()")
    public void update(ProductDto dto) {
        repo.save(ProductMapper.toEntity(dto));
    }
}
```