# 🚀 异步与并发编程使用指南 (JDK 25 版)

本模块基于 **JDK 25 虚拟线程 (Virtual Threads)** 构建，旨在提供高性能、低延迟的异步处理能力，同时解决传统多线程编程中的上下文丢失和资源竞争问题。

## 1. 核心理念

*   **全面虚拟化**：除了 CPU 密集型任务，所有异步任务默认运行在虚拟线程中。
*   **不再池化**：对于 I/O 密集型任务，我们采用“一任务一线程”的模式，不再通过固定大小的线程池限制吞吐量。
*   **阻塞无罪**：在虚拟线程中，你可以放心地使用 `sleep()`、`join()` 或同步调用，这只会挂起虚拟线程，而不会阻塞系统底层线程。
*   **上下文透传**：系统通过 `TaskDecorator` 自动处理 `MDC (TraceId)` 的透传，确保日志链路完整。

---

## 2. 异步执行器 (Executors) 概览

系统中预定义了四种执行器，请根据任务类型选择：

| 执行器名称 | 对应 Bean 名称 | 线程类型 | 适用场景 |
| :--- | :--- | :--- | :--- |
| **默认执行器** | `applicationTaskExecutor` | 虚拟线程 | 通用业务异步、发送通知、记录日志 |
| **IO 执行器** | `ioExecutor` | 虚拟线程 | HTTP 调用、OSS 上传下载、第三方 RPC |
| **批量执行器** | `batchExecutor` | 虚拟线程 | **带限流 (50)**，适用于报表生成、数据同步（保护 DB） |
| **CPU 执行器** | `cpuExecutor` | **平台线程** | 复杂计算、加解密、图片压缩（避免 Pinning 问题） |

---

## 3. 使用方式

### 3.1 注解方式 (@Async)

这是最常用的方式，适用于 Spring 管理的 Bean 方法。

```java
@Service
public class OrderService {

    // 1. 使用默认执行器 (虚拟线程)
    @Async
    public void sendEmail(String email) {
        // 逻辑...
    }

    // 2. 指定 IO 执行器
    @Async("ioExecutor")
    public void callRemoteApi() {
        // 网络调用...
    }

    // 3. 指定批量执行器 (受限流保护)
    @Async("batchExecutor")
    public void exportBigData() {
        // 数据库密集操作...
    }
}
```

### 3.2 工具类方式 (AsyncUtils)

适用于非 Bean 类，或者希望在方法内部开启局部异步块的情况。

```java
// 1. 简单的火后即焚 (Fire-and-forget)
AsyncUtils.run(() -> log.info("异步记录日志"));

// 2. 并行获取数据并等待结果 (Fan-out)
List<Object> data = AsyncUtils.joinAll(List.of(
    () -> userClient.getInfo(userId),
    () -> orderClient.getDetail(orderId)
));

// 3. 批量限流处理 (Throttled Parallel)
AsyncUtils.parallelBatch(userList, user -> {
    userService.update(user); // 同时最多只有 50 个任务在运行
    return true;
});
```

---

## 4. 本地锁 (@LocalLock)

在虚拟线程环境下，我们使用 `@LocalLock` 代替 `synchronized`。该注解基于 `ReentrantLock` 实现，支持 SpEL 表达式。

### 为什么不直接用 synchronized？
在 JDK 25 中，虽然虚拟线程对 `synchronized` 的性能有所优化，但在执行 `synchronized` 块中的阻塞 I/O 时，仍可能导致虚拟线程被“钉住 (Pinned)”在底层载体线程上。使用 `ReentrantLock` 可以完全避免此问题。

### 使用示例：
```java
@Service
public class StockService {

    /**
     * 针对商品 ID 加锁，防止超卖
     * key 支持 SpEL 表达式：#productId 引用参数
     */
    @LocalLock(key = "'stock_lock:' + #productId", waitTime = 5)
    public void deductStock(Long productId, Integer count) {
        // 扣减库存逻辑...
    }
}
```

---

## 5. 日志与链路追踪

系统已配置 **MDC 自动装饰器**。当你使用 `@Async` 或 `AsyncUtils` 时，主线程的 `TraceId` 会自动传递给子线程。

**日志效果展示：**
```text
[MainThread] [TraceId: A123] INFO - 接收请求
[vt-default-1] [TraceId: A123] INFO - 异步处理开始  <-- TraceId 自动带入
```

---

## 6. 开发规范与注意事项 (Important)

1.  **不要池化虚拟线程**：严禁使用 `Executors.newFixedThreadPool(100)` 来运行虚拟线程，这会违背虚拟线程的设计初衷。
2.  **谨慎对待数据库连接池**：虚拟线程虽然可以开 10 万个，但你的数据库连接池（如 HikariCP）通常只有 50-100 个。在大批量异步操作中，请务必使用 `batchExecutor` 或 `AsyncUtils.parallelBatch` 来限流，否则会爆出 `Connection is not available` 错误。
3.  **避免在循环中开启异步**：
    *   ❌ **错误**：`for(item : list) { asyncService.do(item); }` (可能瞬间产生几万个线程压垮下游)
    *   ✅ **正确**：使用 `AsyncUtils.parallelBatch(list, item -> ...)` 进行有保护的并发。
4.  **异常处理**：`@Async` 方法抛出的异常将被 `CustomAsyncExceptionHandler` 捕获并记录日志。如果需要手动捕获，请使用 `CompletableFuture.exceptionally()`。
5.  **ThreadLocal 建议**：虚拟线程中可以使用 `ThreadLocal`，但请确保存放的对象轻量且使用后及时 `remove`。

---

## 7. 常见问题 (FAQ)

**Q: 虚拟线程真的不需要设置最大线程数吗？**
A: 对于 I/O 密集型任务（如查询接口），是的。虚拟线程非常轻量，系统可以根据内存情况支撑百万级线程。瓶颈通常不在线程数，而在你的下游资源（如数据库、第三方 API 限制）。

**Q: 我该什么时候用 cpuExecutor？**
A: 当你的代码在进行复杂的 JSON 解析、大规模加解密、排序算法或图像处理，且这些操作不涉及 I/O 阻塞时，请使用 `cpuExecutor` 调度到平台线程。

---
*版本：1.0.0*
*基座：JDK 25 / Spring Boot 3.x*